
##################################################################################
#' Assign best target/s for each peak
#'
#' This function checks the different targets assigned for a peak and returns the
#' optimum target gene/s. See \strong{Use of arguments} section for more details.
#'
#' @section Use of arguments:
#' \subsection{insideSkewToEndCut}{
#' Use of \code{select_optimal_targets(..., insideSkewToEndCut = 0.7, promoterLength = 500)}
#' \preformatted{
#' #                                                                            #
#' #                  d<500bp                                                   #
#' #      target1    |<---->|    target2           |<--500-->|      target3     #
#' #                        0  0.25  0.5  0.75  1                               #
#' #    ====<====<===       =====>=====>=====>=~~~~           ====>====>===     #
#' #                         --^--            --^--                             #
#' #                         peak1            peak2                             #
#' #                        |<----0.7---->|                                     #
#' #                        **                                                  #
#' #                                                                            #
#' In first example, peak1 is inside target2 and it is near the start of target2.
#' Even though peak1-target1 distance is < 500bp, target1 is marked as pseudo here.
#' In another example, peak2 is inside target2 but it is near the end at 3'UTR.
#' Relative position of the peak2 is >0.7 in target2. peak2 is also upstream of
#' target3 and within (upstreamLimit)bp. So correct annotations are:
#' peak1: target2
#' peak2: target2, target3
#' }
#' }
#'
#'
#' @param targetGr peak annotation in form of GRanges object. This is generated by
#' combining \code{UTR_annotate(), region_annotations(), upstream_annotations()}
#' functions.
#' @param insideSkewToEndCut A floating point number in range [0, 1]. If a peak is
#' present inside feature/gene and the relative summit position is >
#' \code{insideSkewToEndCut}, it is closer to the end of the feature. Default: 0.7
#' @param bindingInGene Logical: whether the ChIPseq TF binds in gene body. This is
#' useful for polII ChIPseq data. Default: FALSE
#'
#' @inheritParams nearest_upstream_bidirectional
#'
#' @return Same GRanges object as peakGr but with modified peakAnnotation column or excluding
#' some targets which were not optimum.
#' @export
#'
#' @examples NA
select_optimal_targets <- function(targetGr, promoterLength, upstreamLimit,
                                   bindingInGene, insideSkewToEndCut,
                                   bidirectionalSkew, bidirectionalDistance){

  pointBasedAnnotation <- get(x = "pointBasedAnnotation", envir = txdbEnv)

  ## important to sort the targets based on peakDist and relativePeakPos
  ## rowIdx will be used later to extract correct targets
  targetDf <- as.data.frame(targetGr) %>%
    dplyr::arrange(seqnames, start, preference, peakDist, relativePeakPos) %>%
    dplyr::mutate(rowIdx = 1:n(),
                  target = TRUE)

  subData <- targetDf %>%
    dplyr::select(seqnames, start, end, name, peakCategory, peakDist, summitDist,
                  relativePeakPos, targetOverlap, peakOverlap, rowIdx, target)

  masterIndexDf <- tibble::tibble(name = unique(subData$name))
  peakFound <- masterIndexDf
  peakDistDf <- masterIndexDf
  summitDistDf <- masterIndexDf
  summitPosDf <- masterIndexDf
  targetOvlpDf <- masterIndexDf
  peakOvlpDf <- masterIndexDf

  ## create dataframes with columns for each peak category
  ## each row is a peak and elements are stores as list of values of interest
  for (ctg in c("featureInPeak", "nearStart", "nearEnd", "peakInFeature", "upstreamTss")) {
    groupedDf <- dplyr::filter(subData, peakCategory == ctg) %>%
      dplyr::select(name, rowIdx, target, peakDist, summitDist,
                    relativePeakPos, targetOverlap, peakOverlap) %>%
      dplyr::group_by(name) %>%
      dplyr::arrange(rowIdx, .by_group = T)

    ## get the peak target GRanges row index for each peak category
    indexDf <- dplyr::summarise(groupedDf, !!ctg := list(rowIdx))
    masterIndexDf <- dplyr::left_join(x = masterIndexDf, y = indexDf, by = "name")

    ## create logical vector for foundPeak data for each peak category
    isTargetDf <- dplyr::summarise(groupedDf, !!ctg := any(target))
    peakFound <- dplyr::left_join(x = peakFound, y = isTargetDf, by = "name")

    ## create peak distance df for each peak category
    distDf <- dplyr::summarise(groupedDf, !!ctg := list(peakDist))
    peakDistDf <- dplyr::left_join(x = peakDistDf, y = distDf, by = "name")

    ## create summit distance df for each peak category
    summitDf <- dplyr::summarise(groupedDf, !!ctg := list(summitDist))
    summitDistDf <- dplyr::left_join(x = summitDistDf, y = summitDf, by = "name")

    ## create peak position df for each peak category
    posDf <- dplyr::summarise(groupedDf, !!ctg := list(relativePeakPos))
    summitPosDf <- dplyr::left_join(x = summitPosDf, y = posDf, by = "name")

    ## create target overlap df for each cateogry
    targetCov <- dplyr::summarise(groupedDf, !!ctg := list(targetOverlap))
    targetOvlpDf <- dplyr::left_join(x = targetOvlpDf, y = targetCov, by = "name")

    ## create peak overlap df for each category
    peakCov <- dplyr::summarise(groupedDf, !!ctg := list(peakOverlap))
    peakOvlpDf <- dplyr::left_join(x = peakOvlpDf, y = peakCov, by = "name")
  }

  ## Future development: use priority list of peak category to select peak targets
  markPseudoIdx <- c()
  bidirectBIdx <- c()
  bidirectCIdx <- c()

  ## "featureInPeak", "nearStart", "nearEnd", "peakInFeature", "upstreamTss"
  ## nearStart peak
  ###########
  ## A1) nearStart & upstreamTss:
  ruleA1 <- which(peakFound$nearStart & peakFound$upstreamTss)
  # targetDf[unlist(masterIndexDf$nearStart[ruleA1]), ]

  ruleA1_bidirectIndex <- tibble::tibble(
    masterIndex = ruleA1,
    nearStart = masterIndexDf$nearStart[ruleA1],
    upstreamTss = masterIndexDf$upstreamTss[ruleA1]
  ) %>%
    tidyr::unnest(cols = c(nearStart, upstreamTss)) %>%
    dplyr::mutate(
      nearStartStrand = targetDf$targetStrand[nearStart],
      upstreamTssStrand = targetDf$targetStrand[upstreamTss]
    ) %>%
    dplyr::mutate(
      strandMatch = if_else(condition = nearStartStrand == upstreamTssStrand,
                            true = "same", false = "opposite")
    )

  ruleA1_sameDirUp <- ruleA1_bidirectIndex$masterIndex[
    which(ruleA1_bidirectIndex$strandMatch == "same")]

  ruleA1_bidirectPseudo <- nearest_upstream_bidirectional(
    targetDf = targetDf,
    t1Idx = ruleA1_bidirectIndex$nearStart,
    t2Idx = ruleA1_bidirectIndex$upstreamTss,
    promoterLength = promoterLength,
    upstreamLimit = upstreamLimit,
    bidirectionalDistance = bidirectionalDistance,
    pointBasedAnnotation = pointBasedAnnotation
  )

  ruleA1_bidirect <- purrr::map2(
    .x = ruleA1_bidirectIndex$nearStart,
    .y = ruleA1_bidirectIndex$upstreamTss,
    .f = function(x, y){
      if(any(c(x, y) %in% ruleA1_bidirectPseudo)){
        return(NULL)
      } else{
        return(c(x, y))
      }
    }) %>%
    purrr::flatten_int()

  ## ACTION: mark upstreamTss as pseudo based on nearest_upstream_bidirectional()
  ## no need to use masterIndexDf as ruleA1_bidirectPseudo has indices from targetDf
  markPseudoIdx <- append(markPseudoIdx, ruleA1_bidirectPseudo)
  bidirectBIdx <- union(bidirectBIdx, ruleA1_bidirect)

  ruleA1_farUp <- ruleA1[purrr::map_lgl(.x = peakDistDf$upstreamTss[ruleA1],
                                        .f = function(x){abs(x[1]) > upstreamLimit})]

  ## additionally add targets which are in same direction to mark them as NULL
  ## use union to remove duplicates
  ruleA1_farUp <- union(x = ruleA1_farUp, ruleA1_sameDirUp)

  ## ACTION: set the upstreamTss to NULL if it is far than promoterLength
  masterIndexDf$upstreamTss[ruleA1_farUp] <- purrr::map(
    .x = masterIndexDf$upstreamTss[ruleA1_farUp],
    .f = ~ NULL)

  peakFound$upstreamTss[ruleA1_farUp] <- FALSE


  ###########
  ## A2) nearStart & nearEnd:
  ruleA2 <- which(peakFound$nearStart & peakFound$nearEnd)
  # targetDf[unlist(masterIndexDf$nearStart[ruleA2]), ]

  ## ACTION: set TES target to NULL
  masterIndexDf$nearEnd[ruleA2] <- purrr::map(.x = masterIndexDf$nearEnd[ruleA2],
                                              .f = ~ NULL)
  peakFound$nearEnd[ruleA2] <- FALSE


  ###########
  ## A3) nearStart & peakInFeature:
  ruleA3 <- which(peakFound$nearStart & peakFound$peakInFeature)
  # targetDf[unlist(masterIndexDf$nearStart[ruleA3]), ]
  ## ACTION: nothing

  ###########
  ## A4) nearStart & featureInPeak:
  ruleA4 <- which(peakFound$nearStart & peakFound$featureInPeak)
  # targetDf[unlist(masterIndexDf$nearStart[ruleA4]), ]
  ## ACTION: nothing

  ## featureInPeak peak
  ###########
  ## B1) featureInPeak & nearEnd:
  ruleB1 <- which(peakFound$featureInPeak & peakFound$nearEnd)
  # targetDf[unlist(masterIndexDf$featureInPeak[ruleB1]), ]

  ## ACTION: remove nearEnd target
  masterIndexDf$nearEnd[ruleB1] <- purrr::map(.x = masterIndexDf$nearEnd[ruleB1],
                                              .f = ~ NULL)
  peakFound$nearEnd[ruleB1] <- FALSE


  ###########
  ## B2) featureInPeak & upstreamTss:
  ruleB2 <- which(peakFound$featureInPeak & peakFound$upstreamTss)
  # targetDf[unlist(masterIndexDf$featureInPeak[ruleB2]), ]

  ## ********************* :future development: *******************************
  ## work only on masterIndexDf and peakFound. use index directly to comapre/extract
  ## various values from targetDf
  # ruleB2_index <- masterIndexDf[ruleB2, ] %>%
  #   dplyr::select(name, featureInPeak, upstreamTss) %>%
  #   tidyr::unnest(cols = c(featureInPeak, upstreamTss))
  ## ********************* :future development: *******************************

  ruleB2_farUp <- ruleB2[purrr::map_lgl(.x = peakDistDf$upstreamTss[ruleB2],
                                        .f = function(x){abs(x[1]) > upstreamLimit})]

  ruleB2_upLimit <- setdiff(ruleB2, ruleB2_farUp)

  ## ACTION: set the upstreamTss to NULL if it is far than promoterLength
  masterIndexDf$upstreamTss[ruleB2_farUp] <- purrr::map(
    .x = masterIndexDf$upstreamTss[ruleB2_farUp],
    .f = ~ NULL)

  peakFound$upstreamTss[ruleB2_farUp] <- FALSE

  ## ACTION: for the TF which has known binding over gene body (E.g. polII ChIP or histone marks)
  ## preference is for featureInPeak. all other targets are pseudo
  if(bindingInGene){
    masterIndexDf$upstreamTss[ruleB2] <- purrr::map(.x = masterIndexDf$upstreamTss[ruleB2],
                                                    .f = ~ NULL)
    peakFound$upstreamTss[ruleB2] <- FALSE

  } else{
    ## set bidirectional = 2
    bidirectCIdx <- c(unlist(masterIndexDf$upstreamTss[ruleB2_upLimit]),
                      unlist(masterIndexDf$featureInPeak[ruleB2_upLimit]))

  }


  ###########
  ## B3) featureInPeak & peakInFeature:
  ruleB3 <- which(peakFound$featureInPeak & peakFound$peakInFeature)
  # targetDf[unlist(masterIndexDf$featureInPeak[ruleB3]), ]

  if(bindingInGene){
    ## for the TF which has known binding over gene body (E.g. polII ChIP or histone marks)
    ## ACTION: set peakInFeature to NULL
    masterIndexDf$peakInFeature[ruleB3] <- purrr::map(.x = masterIndexDf$peakInFeature[ruleB3],
                                                      .f = ~ NULL)
    peakFound$peakInFeature[ruleB3] <- FALSE
  } else{
    ## ACTION: set featureInPeak to NULL
    masterIndexDf$featureInPeak[ruleB3] <- purrr::map(.x = masterIndexDf$featureInPeak[ruleB3],
                                                      .f = ~ NULL)
    peakFound$featureInPeak[ruleB3] <- FALSE
  }

  ###########
  ## C1) upstreamTss & nearEnd:
  ruleC1 <- which(peakFound$upstreamTss & peakFound$nearEnd)
  # targetDf[unlist(masterIndexDf$upstreamTss[ruleC1]), ]

  ruleC1_pro <- ruleC1[purrr::map_lgl(.x = peakDistDf$upstreamTss[ruleC1],
                                      .f = function(x){abs(x[1]) <= promoterLength})]

  ## peaks which also have upstreamTss but its far than upstreamLimit
  ruleC1_farUp <- ruleC1[purrr::map_lgl(.x = peakDistDf$upstreamTss[ruleC1],
                                        .f = function(x){abs(x[1]) > upstreamLimit})]

  ## peaks which upstream but within upstreamLimit range
  ruleC1_upLimit <- setdiff(x = ruleC1, y = ruleC1_farUp)
  ruleC1_nearUp <- setdiff(x = ruleC1, y = c(ruleC1_pro, ruleC1_farUp))

  ## among these ruleC1_nearUp peaks, check: nearEnd has peak summit after insideSkewToEndCut OR
  ## the peak overlap with nearEnd target is very small. i.e. find nearEnd targets where peaks
  ## are at very end of the target. upstreamTss targets should be TRUE for these
  ruleC1_veryEnd <- purrr::map2_lgl(
    .x = summitPosDf$nearEnd[ruleC1_nearUp],
    .y = peakOvlpDf$nearEnd[ruleC1_nearUp],
    .f = function(x, y){x[1] >= insideSkewToEndCut || y[1] < 0.1})

  ## #********************************************************************************##
  ## using 0.1 as cutoff for peakOverlap. later can be converted to function argument ##
  ## #********************************************************************************##

  ## ACTION: set upstreamTss = NULL if: upstreamTss is far & nearEnd is not at very end
  masterIndexDf$upstreamTss[ruleC1_farUp] <- purrr::map(
    .x = masterIndexDf$upstreamTss[ruleC1_farUp],
    .f = ~ NULL)

  peakFound$upstreamTss[ruleC1_farUp] <- FALSE

  ## add ruleC1_nearUp peaks which are also ruleC1_veryEnd to ruleC1_pro
  ruleC1_pro <- append(ruleC1_pro, ruleC1_nearUp[ruleC1_veryEnd])

  ## ACTION: set the nearEnd peaks to pseudo because:
  ## it is upstreamTss within promoter OR (nearUp range and it is at very end for nearEnd)
  markPseudoIdx <- append(markPseudoIdx, unlist(masterIndexDf$nearEnd[ruleC1_pro]))


  ###########
  ## C2) upstreamTss & peakInFeature:
  ruleC2 <- which(peakFound$upstreamTss & peakFound$peakInFeature)
  # targetDf[unlist(masterIndexDf$upstreamTss[ruleC2]), ]

  ###### Planned modification ####################################################
  ## use the TSS distance when peak is inside of gene1 and upstream of another  ##
  ################################################################################

  ruleC2_pro <- ruleC2[purrr::map_lgl(.x = peakDistDf$upstreamTss[ruleC2],
                                      .f = function(x){abs(x[1]) <= promoterLength})]

  ruleC2_farUp <- ruleC2[purrr::map_lgl(.x = peakDistDf$upstreamTss[ruleC2],
                                        .f = function(x){abs(x[1]) > upstreamLimit})]

  ## accept all upstreamTss < promoterLength i.e. ruleC2_pro and mark bidirectional
  ## reject all upstreamTss > upstreamLimit i.e. ruleC2_farUp

  ## promoterLength < upstreamTss < upstreamLimit: decide using nearest_upstream_bidirectional()
  ruleC2_nearUp <- setdiff(x = ruleC2, y = c(ruleC2_pro, ruleC2_farUp))


  ## identify ruleC2_nearUp peaks which are near start for peakInFeature
  ruleC2_nearUp_ovStart <- ruleC2_nearUp[purrr::map_lgl(
    .x = summitPosDf$peakInFeature[ruleC2_nearUp],
    .f = function(x){all(x < (1 - insideSkewToEndCut))})]

  ## solve this using nearest_upstream_bidirectional()
  ruleC2_bidirectIndex <- tibble::tibble(
    masterIndex = ruleC2_nearUp_ovStart,
    peakInFeature = masterIndexDf$peakInFeature[ruleC2_nearUp_ovStart],
    upstreamTss = masterIndexDf$upstreamTss[ruleC2_nearUp_ovStart]
  ) %>%
    tidyr::unnest(cols = c(peakInFeature, upstreamTss)) %>%
    dplyr::mutate(
      peakInFeatureStrand = targetDf$targetStrand[peakInFeature],
      upstreamTssStrand = targetDf$targetStrand[upstreamTss]
    ) %>%
    dplyr::mutate(
      strandMatch = if_else(condition = peakInFeatureStrand == upstreamTssStrand,
                            true = "same", false = "opposite")
    )

  # ruleC2_targetDf <- targetDf
  # ruleC2_targetDf$targetStart[ruleC2_bidirectIndex$peakInFeature] <- dplyr::if_else(
  #   condition = ruleC2_targetDf$targetStrand[ruleC2_bidirectIndex$peakInFeature] == "+",
  #   true = ruleC2_targetDf$peakSummit[ruleC2_bidirectIndex$peakInFeature],
  #   false = ruleC2_targetDf$targetStart[ruleC2_bidirectIndex$peakInFeature])
  #
  # ruleC2_targetDf$targetEnd[ruleC2_bidirectIndex$peakInFeature] <- dplyr::if_else(
  #   condition = ruleC2_targetDf$targetStrand[ruleC2_bidirectIndex$peakInFeature] == "-",
  #   true = ruleC2_targetDf$peakSummit[ruleC2_bidirectIndex$peakInFeature],
  #   false = ruleC2_targetDf$targetEnd[ruleC2_bidirectIndex$peakInFeature])

  ruleC2_bidirectPseudo <- nearest_upstream_bidirectional(
    targetDf = targetDf,
    t1Idx = ruleC2_bidirectIndex$peakInFeature,
    t2Idx = ruleC2_bidirectIndex$upstreamTss,
    promoterLength = promoterLength,
    upstreamLimit = upstreamLimit,
    bidirectionalDistance = bidirectionalDistance,
    pointBasedAnnotation = pointBasedAnnotation
  )

  ruleC2_bidirect <- purrr::map2(
    .x = ruleC2_bidirectIndex$peakInFeature,
    .y = ruleC2_bidirectIndex$upstreamTss,
    .f = function(x, y){
      if(any(c(x, y) %in% ruleC2_bidirectPseudo)){
        return(NULL)
      } else{
        return(c(x, y))
      }
    }) %>%
    purrr::flatten_int()

  ## no need to use masterIndexDf as ruleC2_bidirectPseudo has indices from targetDf
  markPseudoIdx <- append(markPseudoIdx, ruleC2_bidirectPseudo)
  bidirectBIdx <- union(bidirectBIdx, unlist(masterIndexDf$peakInFeature[ruleC2_pro]))
  bidirectBIdx <- union(bidirectBIdx, unlist(masterIndexDf$upstreamTss[ruleC2_pro]))
  bidirectBIdx <- union(bidirectBIdx, ruleC2_bidirect)

  ## remaining ruleC2_nearUp: set as NULL
  ruleC2_nearUp_remaining <- setdiff(x = ruleC2_nearUp, y = ruleC2_nearUp_ovStart)
  ruleC2_farUp <- append(ruleC2_farUp, ruleC2_nearUp_remaining)

  ## ACTION: set upstreamTss = NULL if: upstreamTss is beyond upstreamLimit
  masterIndexDf$upstreamTss[ruleC2_farUp] <- purrr::map(
    .x = masterIndexDf$upstreamTss[ruleC2_farUp],
    .f = ~ NULL)

  peakFound$upstreamTss[ruleC2_farUp] <- FALSE


  ###########
  ## D1) peakInFeature & nearEnd:
  ruleD1 <- which(peakFound$peakInFeature & peakFound$nearEnd)
  # targetDf[unlist(masterIndexDf$peakInFeature[ruleD1]), ]
  ## ACTION: nothing

  ###########
  ## for upstreamTss peak
  ## 8) two upstreamTss peaks: remove pseudo_upstream if peakDist > promoterLength
  ## ACTION: already taken care of in upstream_annotations()


  ## mark selected targets to pseudo
  targetDf$peakAnnotation[markPseudoIdx] <- paste("pseudo_", targetDf$peakAnnotation[markPseudoIdx], sep = "")

  ## add bidirectional information
  targetDf$bidirectional[bidirectBIdx] <- "B"
  targetDf$bidirectional[bidirectCIdx] <- "C"

  ## get the true targets
  trueTargetIdx <- c()
  for (ctg in c("featureInPeak", "nearStart", "nearEnd", "peakInFeature", "upstreamTss")) {
    trueTargetIdx <- append(x = trueTargetIdx,
                            values = unlist(masterIndexDf[[ctg]]))
  }
  trueTargetIdx <- unique(trueTargetIdx)

  peakTargetsGr <- targetDf[trueTargetIdx, ] %>%
    dplyr::select(-rowIdx, -target) %>%
    GenomicRanges::makeGRangesFromDataFrame(keep.extra.columns = T)

  return(peakTargetsGr)

}


##################################################################################
